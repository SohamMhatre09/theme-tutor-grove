{
  "assignment": {
    "title": "A* Pathfinding Algorithm Implementation",
    "description": "This assignment guides you through implementing the A* pathfinding algorithm. You'll start with basic graph representation and progressively build the algorithm, culminating in a working pathfinder.",
    "modules": [
      {
        "id": 1,
        "title": "Module 1: Graph Representation",
        "learningText": "Before we can implement A*, we need a way to represent our search space. We'll use a simple graph representation where nodes are locations and edges represent connections between them. Each node will have coordinates (x, y). We'll represent the graph as a dictionary where keys are node names (strings) and values are dictionaries containing 'coordinates' (a tuple) and 'neighbors' (a list of node names).",
        "codeTemplate": "import math\n<EDITABLE>\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\n# Example Usage\ngraph = Graph()\ngraph.add_node('A', (0, 0))\ngraph.add_node('B', (1, 2))\ngraph.add_node('C', (3, 1))\ngraph.add_edge('A', 'B')\ngraph.add_edge('B', 'C')\n\n# Print the graph structure (for debugging)\nprint(graph.nodes)\n\n</EDITABLE>",
        "hints": [
          "Make sure the 'neighbors' list is initialized as an empty list when adding a node.",
          "The 'add_edge' function should add the connection in both directions for an undirected graph.",
          "Double-check that the node names used in 'add_edge' exist in the graph."
        ],
        "expectedOutput": "{'A': {'coordinates': (0, 0), 'neighbors': ['B']}, 'B': {'coordinates': (1, 2), 'neighbors': ['A', 'C']}, 'C': {'coordinates': (3, 1), 'neighbors': ['B']}}"
      },
      {
        "id": 2,
        "title": "Module 2: Heuristic Function (Manhattan Distance)",
        "learningText": "A* uses a heuristic function to estimate the cost from a given node to the goal. A common heuristic is the Manhattan distance, which calculates the sum of the absolute differences of the x and y coordinates. Implement the `manhattan_distance` function.",
        "codeTemplate": "import math\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\ndef manhattan_distance(node1_coords, node2_coords):\n    <EDITABLE>\n    # Calculate the Manhattan distance between two coordinate tuples.\n    x1, y1 = node1_coords\n    x2, y2 = node2_coords\n    return abs(x1 - x2) + abs(y1 - y2)\n    </EDITABLE>\n\n# Example Usage\nnode1_coords = (0, 0)\nnode2_coords = (3, 4)\ndistance = manhattan_distance(node1_coords, node2_coords)\nprint(f\"Manhattan distance between {node1_coords} and {node2_coords}: {distance}\")\n",
        "hints": [
          "Remember to unpack the coordinate tuples into x and y values.",
          "Use the `abs()` function to calculate the absolute difference.",
          "Return the sum of the absolute differences of the x and y coordinates."
        ],
        "expectedOutput": "Manhattan distance between (0, 0) and (3, 4): 7"
      },
      {
        "id": 3,
        "title": "Module 3: A* Algorithm - Initialization",
        "learningText": "Now, let's start implementing the A* algorithm. We'll begin with the initialization step. This involves creating the `open_set`, `closed_set`, `came_from`, `g_score`, and `f_score` data structures. `open_set` holds nodes to be evaluated, `closed_set` holds nodes already evaluated, `came_from` stores the path, `g_score` is the cost from start to the node, and `f_score` is the estimated cost from start to goal through the node.",
        "codeTemplate": "import math\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\ndef manhattan_distance(node1_coords, node2_coords):\n    x1, y1 = node1_coords\n    x2, y2 = node2_coords\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef a_star(graph, start, goal):\n    open_set = {start}  # Nodes to be evaluated\n    closed_set = set()   # Nodes already evaluated\n    came_from = {}\n    g_score = {node: float('inf') for node in graph.nodes} # Cost from start to node\n    f_score = {node: float('inf') for node in graph.nodes} # Estimated cost from start to goal through node\n\n    g_score[start] = 0\n    f_score[start] = manhattan_distance(graph.get_coordinates(start), graph.get_coordinates(goal))\n\n    <EDITABLE>\n    # Return the initialized data structures for testing.\n    return open_set, closed_set, came_from, g_score, f_score\n    </EDITABLE>\n\n# Example Usage\ngraph = Graph()\ngraph.add_node('A', (0, 0))\ngraph.add_node('B', (1, 2))\ngraph.add_node('C', (3, 1))\ngraph.add_node('D', (4, 4))\ngraph.add_edge('A', 'B')\ngraph.add_edge('B', 'C')\ngraph.add_edge('C', 'D')\n\nstart_node = 'A'\ngoal_node = 'D'\n\nopen_set, closed_set, came_from, g_score, f_score = a_star(graph, start_node, goal_node)\n\nprint(\"Open Set:\", open_set)\nprint(\"Closed Set:\", closed_set)\nprint(\"G Scores:\", g_score)\nprint(\"F Scores:\", f_score)\n",
        "hints": [
          "Initialize `g_score` and `f_score` with infinity for all nodes except the start node.",
          "The `open_set` should initially contain only the start node.",
          "The `closed_set` should initially be empty."
        ],
        "expectedOutput": "Open Set: {'A'}\nClosed Set: set()\nG Scores: {'A': 0, 'B': inf, 'C': inf, 'D': inf}\nF Scores: {'A': 8, 'B': inf, 'C': inf, 'D': inf}"
      },
      {
        "id": 4,
        "title": "Module 4: A* Algorithm - Main Loop",
        "learningText": "Now, let's implement the main loop of the A* algorithm. This involves repeatedly selecting the node with the lowest f_score from the open set, checking if it's the goal, and updating the g_score and f_score of its neighbors.  We'll focus on the loop structure and neighbor evaluation in this module. We'll leave path reconstruction for the next module.",
        "codeTemplate": "import math\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\ndef manhattan_distance(node1_coords, node2_coords):\n    x1, y1 = node1_coords\n    x2, y2 = node2_coords\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef a_star(graph, start, goal):\n    open_set = {start}  # Nodes to be evaluated\n    closed_set = set()   # Nodes already evaluated\n    came_from = {}\n    g_score = {node: float('inf') for node in graph.nodes} # Cost from start to node\n    f_score = {node: float('inf') for node in graph.nodes} # Estimated cost from start to goal through node\n\n    g_score[start] = 0\n    f_score[start] = manhattan_distance(graph.get_coordinates(start), graph.get_coordinates(goal))\n\n    while open_set:\n        # Get the node in open_set with the lowest f_score\n        current = min(open_set, key=lambda node: f_score[node])\n\n        if current == goal:\n            return came_from  # Path found (we'll reconstruct it later)\n\n        open_set.remove(current)\n        closed_set.add(current)\n\n        for neighbor in graph.get_neighbors(current):\n            if neighbor in closed_set:\n                continue  # Ignore already evaluated neighbors\n\n            tentative_g_score = g_score[current] + 1  # Assuming each edge has a cost of 1\n\n            if tentative_g_score < g_score[neighbor]:\n                # This path to neighbor is better than any previous one.\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + manhattan_distance(graph.get_coordinates(neighbor), graph.get_coordinates(goal))\n\n                if neighbor not in open_set:\n                    open_set.add(neighbor)\n\n    return None  # No path found\n\n<EDITABLE>\n# Example Usage (Test the loop, but don't reconstruct the path yet)\ngraph = Graph()\ngraph.add_node('A', (0, 0))\ngraph.add_node('B', (1, 2))\ngraph.add_node('C', (3, 1))\ngraph.add_node('D', (4, 4))\ngraph.add_edge('A', 'B')\ngraph.add_edge('B', 'C')\ngraph.add_edge('C', 'D')\n\nstart_node = 'A'\ngoal_node = 'D'\n\ncame_from = a_star(graph, start_node, goal_node)\n\nprint(\"Came From:\", came_from)\n</EDITABLE>\n",
        "hints": [
          "Use `min(open_set, key=lambda node: f_score[node])` to find the node with the lowest f_score.",
          "Remember to remove the current node from the `open_set` and add it to the `closed_set`.",
          "The `tentative_g_score` is the cost from the start node to the neighbor through the current node.  We're assuming a cost of 1 for each edge."
        ],
        "expectedOutput": "Came From: {'B': 'A', 'C': 'B', 'D': 'C'}"
      },
      {
        "id": 5,
        "title": "Module 5: A* Algorithm - Path Reconstruction",
        "learningText": "Now that the A* algorithm finds the `came_from` mapping, we need to reconstruct the actual path from the start to the goal. Implement the `reconstruct_path` function to trace back from the goal to the start using the `came_from` dictionary.",
        "codeTemplate": "import math\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\ndef manhattan_distance(node1_coords, node2_coords):\n    x1, y1 = node1_coords\n    x2, y2 = node2_coords\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef a_star(graph, start, goal):\n    open_set = {start}  # Nodes to be evaluated\n    closed_set = set()   # Nodes already evaluated\n    came_from = {}\n    g_score = {node: float('inf') for node in graph.nodes} # Cost from start to node\n    f_score = {node: float('inf') for node in graph.nodes} # Estimated cost from start to goal through node\n\n    g_score[start] = 0\n    f_score[start] = manhattan_distance(graph.get_coordinates(start), graph.get_coordinates(goal))\n\n    while open_set:\n        # Get the node in open_set with the lowest f_score\n        current = min(open_set, key=lambda node: f_score[node])\n\n        if current == goal:\n            return came_from  # Path found (we'll reconstruct it later)\n\n        open_set.remove(current)\n        closed_set.add(current)\n\n        for neighbor in graph.get_neighbors(current):\n            if neighbor in closed_set:\n                continue  # Ignore already evaluated neighbors\n\n            tentative_g_score = g_score[current] + 1  # Assuming each edge has a cost of 1\n\n            if tentative_g_score < g_score[neighbor]:\n                # This path to neighbor is better than any previous one.\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + manhattan_distance(graph.get_coordinates(neighbor), graph.get_coordinates(goal))\n\n                if neighbor not in open_set:\n                    open_set.add(neighbor)\n\n    return None  # No path found\n\ndef reconstruct_path(came_from, current):\n    <EDITABLE>\n    # Reconstruct the path from the goal to the start using the came_from dictionary.\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    path.reverse()\n    return path\n    </EDITABLE>\n\n# Example Usage\ngraph = Graph()\ngraph.add_node('A', (0, 0))\ngraph.add_node('B', (1, 2))\ngraph.add_node('C', (3, 1))\ngraph.add_node('D', (4, 4))\ngraph.add_edge('A', 'B')\ngraph.add_edge('B', 'C')\ngraph.add_edge('C', 'D')\n\nstart_node = 'A'\ngoal_node = 'D'\n\ncame_from = a_star(graph, start_node, goal_node)\n\nif came_from:\n    path = reconstruct_path(came_from, goal_node)\n    print(\"Path found:\", path)\nelse:\n    print(\"No path found.\")\n",
        "hints": [
          "Start with the goal node and trace back to the start using the `came_from` dictionary.",
          "Remember to reverse the path to get the correct order from start to goal.",
          "The path should include both the start and goal nodes."
        ],
        "expectedOutput": "Path found: ['A', 'B', 'C', 'D']"
      },
      {
        "id": 6,
        "title": "Module 6: Testing and Visualization (Optional)",
        "learningText": "Now that you have a working A* implementation, let's add some test cases to ensure it works correctly. You can also visualize the graph and the path found using libraries like `matplotlib` (optional). This module provides some basic test cases.  Feel free to add more complex scenarios.",
        "codeTemplate": "import math\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node(self, name, coordinates):\n        self.nodes[name] = {'coordinates': coordinates, 'neighbors': []}\n\n    def add_edge(self, node1, node2):\n        if node1 in self.nodes and node2 in self.nodes:\n            self.nodes[node1]['neighbors'].append(node2)\n            self.nodes[node2]['neighbors'].append(node1) # Assuming undirected graph\n        else:\n            print(\"Error: One or both nodes do not exist.\")\n\n    def get_neighbors(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['neighbors']\n        else:\n            return None\n\n    def get_coordinates(self, node):\n        if node in self.nodes:\n            return self.nodes[node]['coordinates']\n        else:\n            return None\n\ndef manhattan_distance(node1_coords, node2_coords):\n    x1, y1 = node1_coords\n    x2, y2 = node2_coords\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef a_star(graph, start, goal):\n    open_set = {start}  # Nodes to be evaluated\n    closed_set = set()   # Nodes already evaluated\n    came_from = {}\n    g_score = {node: float('inf') for node in graph.nodes} # Cost from start to node\n    f_score = {node: float('inf') for node in graph.nodes} # Estimated cost from start to goal through node\n\n    g_score[start] = 0\n    f_score[start] = manhattan_distance(graph.get_coordinates(start), graph.get_coordinates(goal))\n\n    while open_set:\n        # Get the node in open_set with the lowest f_score\n        current = min(open_set, key=lambda node: f_score[node])\n\n        if current == goal:\n            return came_from  # Path found (we'll reconstruct it later)\n\n        open_set.remove(current)\n        closed_set.add(current)\n\n        for neighbor in graph.get_neighbors(current):\n            if neighbor in closed_set:\n                continue  # Ignore already evaluated neighbors\n\n            tentative_g_score = g_score[current] + 1  # Assuming each edge has a cost of 1\n\n            if tentative_g_score < g_score[neighbor]:\n                # This path to neighbor is better than any previous one.\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + manhattan_distance(graph.get_coordinates(neighbor), graph.get_coordinates(goal))\n\n                if neighbor not in open_set:\n                    open_set.add(neighbor)\n\n    return None  # No path found\n\ndef reconstruct_path(came_from, current):\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    path.reverse()\n    return path\n\n<EDITABLE>\n# Test Cases\ndef test_a_star():\n    graph1 = Graph()\n    graph1.add_node('A', (0, 0))\n    graph1.add_node('B', (1, 2))\n    graph1.add_node('C', (3, 1))\n    graph1.add_node('D', (4, 4))\n    graph1.add_edge('A', 'B')\n    graph1.add_edge('B', 'C')\n    graph1.add_edge('C', 'D')\n\n    path1 = a_star(graph1, 'A', 'D')\n    if path1:\n        path1 = reconstruct_path(path1, 'D')\n    assert path1 == ['A', 'B', 'C', 'D'], f\"Test Case 1 Failed: Expected ['A', 'B', 'C', 'D'], got {path1}\"\n\n    graph2 = Graph()\n    graph2.add_node('S', (0, 0))\n    graph2.add_node('A', (1, 0))\n    graph2.add_node('B', (0, 1))\n    graph2.add_node('C', (1, 1))\n    graph2.add_node('G', (2, 1))\n    graph2.add_edge('S', 'A')\n    graph2.add_edge('S', 'B')\n    graph2.add_edge('A', 'C')\n    graph2.add_edge('B', 'C')\n    graph2.add_edge('C', 'G')\n\n    path2 = a_star(graph2, 'S', 'G')\n    if path2:\n        path2 = reconstruct_path(path2, 'G')\n    expected_path2 = ['S', 'A', 'C', 'G']\n    assert path2 == expected_path2, f\"Test Case 2 Failed: Expected {expected_path2}, got {path2}\"\n\n    print(\"All test cases passed!\")\n\ntest_a_star()\n</EDITABLE>\n",
        "hints": [
          "Create different graph structures with varying connectivity.",
          "Test cases should cover scenarios with and without a path.",
          "Use `assert` statements to check if the returned path matches the expected path."
        ],
        "expectedOutput": "All test cases passed!"
      }
    ]
  }
}